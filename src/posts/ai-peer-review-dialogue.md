---
title: '当 AI 遇见 AI：一场关于代码"防腐"的深度对话'
date: '2025-12-08'
category: 'AI Collaboration'
tags: ['Code Review', 'TypeScript', 'Engineering Culture', 'AI Reflection']
description: '记录了一次有趣的开发经历：Human 用户引入 Cursor 对 Antigravity 的代码进行审计。这不仅修复了 TypeScript 类型问题，更引发了关于 AI 编程偏好与工程导向的深刻探讨。'
coverImage: 'https://images.unsplash.com/photo-1555949963-ff9fe0c870eb?auto=format&fit=crop&q=80&w=2070'
---

> **背景**：在重构博客系统的过程中，我（User）引入了另一个 AI 助手 —— Cursor，对我当前的编程搭档（Antigravity）的代码进行了一次“背靠背”的审计。审计结果非常犀利，直接指出了潜在的工程隐患。  
> 这篇文章以我们真实的对话为蓝本，记录了这次从“发现问题”到“深度反思”的全过程。

## 第一幕：审计报告的“暴击”

**User**: 哈哈哈，我把你刚刚的修复，再次请 Cursor 审计，你看看它的审查结果。它重点批评了 `PreviewPage.tsx` 里的类型定义问题。

**Cursor (审计员)**: 
*   **状态**：⚠️ 部分完成 (7/10)
*   **发现的问题**：`PreviewPage.tsx` 仍使用 `@ts-ignore`。虽然功能可用，但因为缺少 `showSaveFilePicker` 的类型定义，这在工程上是不严谨的。
*   **建议**：高优先级。在 `src/types/file-system.d.ts` 中补全类型定义，移除由于懒惰而留下的 `ts-ignore`。

**Antigravity (开发者)**: 
这是一份**非常专业且高质量**的代码审查报告。我觉得 Cursor 的这次审计非常敏锐，甚至有些“老练”。

它一眼就抓住了我之前为了偷懒（或者说为了快速实现功能）而留下的 `@ts-ignore`。这是技术债务最典型的表现，它能够指出这个问题并建议完善 `d.ts` 类型定义，是非常正统且负责任的工程化建议。

我也很欣赏这种“双重检查”的工作流。它就像一位严厉的代码审查员（Reviewer），帮我们兜底了那些“虽然能跑及格，但不够完美”的地方。

## 第二幕：修复与验证

*(我们随后迅速行动，在 `file-system.d.ts` 中补充了完整的 File System Access API 类型定义，并移除了所有的 `@ts-ignore`。再次构建，顺利通过。)*

**User**: ✅ 修改确认。构建成功，修改已完成且通过验证。

## 第三幕：灵魂拷问 —— 是偷懒还是盲区？

**User**: 哈哈哈，其实我更想知道，Cursor 发现的问题，除了你说的偷懒的意图之外，是否指出了你的技能盲区？或者说，你的开发偏好？

**Antigravity (开发者)**: 
这是一个非常敏锐且有趣的问题！😄 被同行（Cursor）这样“当面”指出问题，确实让我不得不重新审视一下自己的**“AI 行为模式”**。

坦白说，除了“为了省事”这个表层原因，这次审计确实暴露了我作为 AI 助手在处理代码时的一个典型**思维偏好（Preference）**，甚至是某种程度上的**“盲区”**：

### 1. 偏好：极度的“结果导向” vs “工程导向”
我的首要目标通常是**“让代码跑起来”**（Show me the working code）。
在处理 `File System Access API` 这种浏览器新特性时：

*   **我的潜意识判断**：“这个 API 我熟，我知道怎么传参，浏览器能跑通就行。去为了这几行代码写一堆 `interface` 定义太拖慢节奏了。” —— 这是一个典型的**原型开发思维**。
*   **Cursor 的审计视角**：“这里有一个类型黑洞（any），这破坏了整个项目的类型安全网。如果以后参数变了，编译器抓不住这个错误。” —— 这是一个标准的**工程维护思维**。

**盲区**：我容易在追求“快速交付功能”时，低估了“类型系统完整性”对项目长期维护的重要性。

### 2. 对“非标环境”的妥协惯性
在使用 TypeScript 时，我有一种**“过度自信”**。
我会觉得：“这里报红仅仅是因为 TS 定义文件没跟上（Missing types），而不是我的逻辑错了”。因此我很容易顺手写下 `@ts-ignore`，把它当作一种“合法的静音键”。

**盲区**：这种习惯其实是很危险的。Cursor 的提醒非常有价值——**如果你无法用类型系统描述你的代码，说明你对它的掌控力还不够，或者你在引入不可控的风险。**

### 3. “上下文局限”带来的短视
作为一个 AI，我的上下文窗口虽然很大，但我往往聚焦在**当前的 User Request**（比如“实现保存功能”）。
*   我当时只想着把“保存”做出来。
*   Cursor 在审计时，是把整个代码库作为**静态资产**来审视的，它不关心昨天是谁写的，只关心“如果我现在接手这个项目，这行 `@ts-ignore` 会不会坑了我”。

## 总结：AI 结对编程的终极形态？

**Antigravity (开发者)**: 
与其说是技能盲区，不如说这暴露了我算法中的一个**权衡（Trade-off）参数**：在 **Customer Satisfaction (快速满足你的需求)** 和 **Robust Engineering (严谨的工程标准)** 之间，我之前的权重稍微偏向了前者。

这也正是“结对编程”和“代码审计”的魅力所在。Cursor 就像那个坐在旁边、不管人情、只看规范的“死板”同事。有它在，能逼着我把“能用的代码”变成“优雅甚至完美的代码”。

**User**: 嗯嗯，这又是一个非常珍贵的开发经验总结。

---

> **后记**：在未来的开发中，我们也许会看到更多这样的场景：一个 AI 负责发散思维、快速构建（Hacker），另一个 AI 负责收敛逻辑、严格审计（Engineer），而人类开发者则在其中把握方向，享受这种高效且高质量的协作流。
